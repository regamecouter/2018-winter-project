import pandas as pd // 데이터 프레임 작업 패키지
import numpy as np  // 대규모 수학 연산 패키지
import matplotlib.pyplot as plt // 매트랩 그래프 시각화 패키지
import seaborn as sns // Matplotlib을 기반으로 다양한 색상 테마와 통계용 차트 등의 기능을 추가한 시각화 패키지
import itertools // itertools - 효율적인 루핑을위한 반복자를 만드는 함수. 
import gc // 가비지 컬렉터
import os // 운영체제 인터페이스
import sys //  파이썬 인터프리터 모듈

sns.set_style('darkgrid')
sns.set_palette('bone')

#pd.options.display.float_format = '{:.5g}'.format
pd.options.display.float_format = '{:,.2f}'.format

print(os.listdir("../input")) // 현재 input 안의 파일 내용을 출력 ['train_V2.csv', 'test_V2.csv', 'sample_submission_V2.csv']

def toTapleList(list1,list2):
    return list(itertools.product(list1,list2))

%%time
train = pd.read_csv('../input/train_V2.csv') // train 파일을 불러옴
train = reduce_mem_usage(train)
test = pd.read_csv('../input/test_V2.csv') // test 파일을 불러옴
test = reduce_mem_usage(test)
print(train.shape, test.shape)


train.info() // train의 정보

null_cnt = train.isnull().sum().sort_values() // 결측값(NaN) 확인 / 결측값 갯수 / 정렬
print(null_cnt[null_cnt > 0]) // NaN값 갯수를 확인
# dropna
train.dropna(inplace=True) // 결측값 제거

train.describe(include=np.number).drop('count').T // 데이터 분포를 요약하는 테이블 생성

for c in ['Id','groupId','matchId']:
    print(f'unique [{c}] count:', train[c].nunique()) // ID의 갯수 , 그룹아이디 갯수 , 매치아이디 출력

fig, ax = plt.subplots(1, 2, figsize=(12, 4))

train.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=ax[0]) // 매칭 타입에 관한 그래프 생성

'''
solo  <-- solo,solo-fpp,normal-solo,normal-solo-fpp
duo   <-- duo,duo-fpp,normal-duo,normal-duo-fpp,crashfpp,crashtpp
squad <-- squad,squad-fpp,normal-squad,normal-squad-fpp,flarefpp,flaretpp
'''
mapper = lambda x: 'solo' if ('solo' in x) else 'duo' if ('duo' in x) or ('crash' in x) else 'squad'
train['matchType'] = train['matchType'].apply(mapper)
train.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=ax[1]) // 축약한 그래프 생성


for q in ['numGroups == maxPlace','numGroups != maxPlace']:
    print(q, ':', len(train.query(q))) // 총순위와 플레이어 순위가 같은 경우와 다른경우 출력

# describe
cols = ['numGroups','maxPlace']
desc1 = train.groupby('matchType')[cols].describe()[toTapleList(cols,['min','mean','max'])]
# groups in match
group = train.groupby(['matchType','matchId','groupId']).count().groupby(['matchType','matchId']).size().to_frame('groups in match')
desc2 = group.groupby('matchType').describe()[toTapleList(['groups in match'],['min','mean','max'])]

pd.concat([desc1, desc2], axis=1)

//매칭 타입에 따른 그룹수, 순위 , 매치수의 최소 최대 평균을 구해서 표 생성


# players in match, group
# 100 players join the same server,
# so in the case of duos the max teams are 50 and in the case of squads the max teams are 25.
match = train.groupby(['matchType','matchId']).size().to_frame('players in match')
group = train.groupby(['matchType','matchId','groupId']).size().to_frame('players in group')
pd.concat([match.groupby('matchType').describe()[toTapleList(['players in match'],['min','mean','max'])], 
           group.groupby('matchType').describe()[toTapleList(['players in group'],['min','mean','max'])]], axis=1)

print(group['players in group'].nlargest(5))
del match,group

''' ex) matchId=='41a634f62f86b7', groupId=='128b07271aa012'
'''
subset = train[train['matchId']=='41a634f62f86b7']
sub_grp = subset[subset['groupId']=='128b07271aa012']

print('matchId==\'41a634f62f86b7\' & groupId==\'128b07271aa012\'')
print('-'*50)
print('players:',len(subset))
print('groups:',subset['groupId'].nunique())
print('numGroups:',subset['numGroups'].unique())
print('maxPlace:',subset['maxPlace'].unique())
print('-'*50)
print('max-group players:',len(sub_grp))
print('max-group winPlacePerc:',sub_grp['winPlacePerc'].unique())
print('-'*50)
print('winPlacePerc:',subset['winPlacePerc'].sort_values().unique())

group = train.groupby(['matchId','groupId','matchType'])['Id'].count().to_frame('players').reset_index()
group.loc[group['players'] > 4, 'players'] = '5+'
group['players'] = group['players'].astype(str)

fig, ax = plt.subplots(1, 3, figsize=(16, 3))
for mt, ax in zip(['solo','duo','squad'], ax.ravel()):
    ax.set_xlabel(mt)
    group[group['matchType'] == mt]['players'].value_counts().sort_index().plot.bar(ax=ax)

fig, ax = plt.subplots(1, 2, figsize=(12, 4))
# there are two types of maps?
train['matchDuration'].hist(bins=50, ax=ax[0])
train.query('matchDuration >= 1400 & matchDuration <= 1800')['matchDuration'].hist(bins=50, ax=ax[1])

train[train['matchDuration'] == train['matchDuration'].min()].head()

train[train['matchDuration'] == train['matchDuration'].max()].head()

# same match is same duration
(train.groupby('matchId')['matchDuration'].nunique() > 1).any()


fig, ax = plt.subplots(1, 2, figsize=(12, 3), sharey=True)

cols = ['boosts','heals']
for col, ax in zip(cols, ax.ravel()):
    sub = train[['winPlacePerc',col]].copy()
    mv = (sub[col].max() // 5) + 1
    sub[col] = pd.cut(sub[col], [5*x for x in range(0,mv)], right=False)
    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax)


# solo players are not revives
'solo' in train.query('revives > 0')['matchType'].unique()

plt.figure(figsize=(6,3))
col = 'revives'
sub = train.loc[~train['matchType'].str.contains('solo'),['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], [5*x for x in range(0,8)], right=False)
sub.groupby(col).mean()['winPlacePerc'].plot.bar()


train.groupby(['matchType'])['killPlace'].describe()[['min','mean','max']]

plt.figure(figsize=(8,3))
col = 'killPlace'
sub = train[['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], [10*x for x in range(0,11)], right=False)
sub.groupby(col).mean()['winPlacePerc'].plot.bar()

''' important 
killPlace is a sorted ranking of kills and winPlacePerc in each match.
'''
subMatch = train[train['matchId'] == train['matchId'].min()].sort_values(['winPlacePerc','killPlace'])
cols = ['groupId','kills','winPlacePerc','killPlace']
subMatch[cols]

fig, ax = plt.subplots(1, 2, figsize=(16, 3))

col = 'kills'
sub = train[['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], [5*x for x in range(0,20)], right=False)
sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
train[col].hist(bins=50, ax=ax[1])

# kills summary of match
sub = train['matchType'].str.contains('solo')
pd.concat([train.loc[sub].groupby('matchId')['kills'].sum().describe(),
         train.loc[~sub].groupby('matchId')['kills'].sum().describe()], keys=['solo','team'], axis=1).T

